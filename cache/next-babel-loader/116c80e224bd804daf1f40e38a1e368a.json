{"ast":null,"code":"export function parse(text) {\n  const row_lines = text.split('\\n');\n  const arrayOfTimestamps = timestamps(row_lines);\n  const errorTimeString = errorTime(arrayOfTimestamps);\n  return {\n    runningDate: runningDate(row_lines),\n    runningTime: runningTime(row_lines, errorTimeString),\n    jobName: jobName(row_lines),\n    batch: batch(arrayOfTimestamps),\n    uploadTime: uploadTime(arrayOfTimestamps),\n    splitterTime: splitterTime(arrayOfTimestamps),\n    acpTime: acpTime(arrayOfTimestamps),\n    mergerTime: mergerTime(arrayOfTimestamps),\n    downloadTime: downloadTime(arrayOfTimestamps),\n    errorTime: errorTimeString\n  };\n}\n\nfunction jobName(row_lines) {\n  const job_line = row_lines.filter(line => line.match(\"Job:\"))[0];\n  const job_name = job_line.split(' ')[1];\n  return job_name;\n}\n\nfunction runningDate(row_lines) {\n  let arrayOfLines = row_lines.filter(line => line.match(\"time\"));\n  let splitArray = arrayOfLines[0].split(' ');\n  let [day, month, year] = splitArray[1].split(':')[1].split('/');\n  if (day.length > 2) day = day.substr(1);\n  let [hour, min] = splitArray[2].split(':');\n  if (hour.length > 2) hour = hour.substr(1);\n  if (min.length > 2) min = min.substr(1);\n  return new Date(Date.UTC(year, month - 1, day, hour, min)).toUTCString();\n}\n\nfunction runningTime(row_lines, errorTime) {\n  let job_started_line = row_lines.filter(line => line.match(\"Ready for commands\"))[0];\n  let start_time = JSON.parse(job_started_line).time;\n  let job_ended_line = row_lines.filter(line => line.match(\"Job is ready\"));\n  let end_time = job_ended_line.length > 0 ? JSON.parse(job_ended_line).time : errorTime;\n  return secToHHMMSS(time_diff(start_time, end_time));\n} // export function getChartData(data) {\n//     let stats = data.batch.map(action => {\n//         let timestamp = data.acpTime.find(\n//             a => a.Stage === action.Stage && a.Index === action.StageIndex\n//         );\n//         return {\n//             Object: \"Acp\",\n//             ActNum: action.ActNum,\n//             Name: action.AnalysisName,\n//             Layer: action.LayerName,\n//             Stage: action.Stage,\n//             Index: action.StageIndex,\n//             StartTime: timestamp ? timestamp.StartTime : \"\",\n//             CompleteTime: timestamp ? timestamp.CompleteTime : \"\",\n//             Time: time_diff(timestamp.StartTime, timestamp.CompleteTime),\n//             StartDate: new Date(`01/01/1970 ${timestamp.StartTime}`),\n//             EndDate: new Date(`01/01/1970 ${timestamp.CompleteTime}`)\n//         };\n//     });\n//     let splitterObj = {\n//         Object: \"Splitter\",\n//         Name: \"Splitter\",\n//         Index: 0,\n//         StartDate: new Date(`01/01/1970 ${data.splitterTime.StartTime}`),\n//         EndDate: new Date(`01/01/1970 ${data.splitterTime.CompleteTime}`)\n//     };\n//     let mergerObj = {\n//         Object: \"Merger\",\n//         Name: \"Merger\",\n//         Index: stats.length + 1,\n//         StartDate: new Date(`01/01/1970 ${data.mergerTime.StartTime}`),\n//         EndDate: new Date(`01/01/1970 ${data.mergerTime.CompleteTime}`)\n//     };\n//     let uploadObj = {\n//         Object: \"Upload\",\n//         Name: \"Upload\",\n//         Index: -1,\n//         StartDate: new Date(`01/01/1970 ${data.uploadTime.StartTime}`),\n//         EndDate: new Date(`01/01/1970 ${data.uploadTime.CompleteTime}`)\n//     };\n//     let downloadObj = {\n//         Object: \"Download\",\n//         Name: \"Download\",\n//         Index: stats.length + 2,\n//         StartDate: new Date(`01/01/1970 ${data.downloadTime.StartTime}`),\n//         EndDate: new Date(`01/01/1970 ${data.downloadTime.CompleteTime}`)\n//     };\n//     // stats = [uploadObj, splitterObj, ...stats, mergerObj, downloadTime];\n//     stats = [uploadObj, splitterObj, ...stats, mergerObj, downloadObj];\n//     return stats;\n// }\n\n\nfunction batch(arrayOfTimestamps) {\n  let batchObject = arrayOfTimestamps.filter(d => d.type === \"Batch\")[0];\n  return JSON.parse(batchObject.message);\n}\n\nfunction uploadTime(arrayOfTimestamps) {\n  let uploadTime = {\n    StartTime: arrayOfTimestamps.find(d => d.object === \"WebClient\" && d.message === \"Job was registered\").time,\n    CompleteTime: arrayOfTimestamps.find(d => d.object === \"WebClient\" && d.message === \"After send\").time\n  };\n  return uploadTime;\n}\n\nfunction splitterTime(arrayOfTimestamps) {\n  let splitter = arrayOfTimestamps.filter(d => d.object === \"Splitter\");\n  let s = {\n    StartTime: toLocal(splitter.find(s => s.message === \"Splitter started\").time),\n    CompleteTime: toLocal(splitter.find(s => s.message === \"End of Split\").time)\n  };\n  return s;\n}\n\nfunction mergerTime(arrayOfTimestamps) {\n  let merger = arrayOfTimestamps.filter(d => d.object === \"Merger\"); // if (!merger) return null\n\n  let mergerStartMessage = merger.find(s => s.message === \"Preparing job for merge\");\n  let mergerCompleteMessage = merger.find(s => s.message === \"Moving Job to S3\");\n  let s = {\n    StartTime: mergerStartMessage ? toLocal(mergerStartMessage.time) : null,\n    CompleteTime: mergerCompleteMessage ? toLocal(mergerCompleteMessage.time) : null\n  };\n  return s;\n}\n\nfunction downloadTime(arrayOfTimestamps) {\n  let downloadStartMessage = arrayOfTimestamps.find(d => d.object === \"WebClient\" && d.message === \"Download Data\");\n  let downloadCompleteMessage = arrayOfTimestamps.find(d => d.object === \"WebClient\" && d.message === \"Job is ready\");\n  let downloadTime = {\n    StartTime: downloadStartMessage ? downloadStartMessage.time : null,\n    CompleteTime: downloadCompleteMessage ? downloadCompleteMessage.time : null\n  };\n  return downloadTime;\n}\n\nfunction acpTime(arrayOfTimestamps) {\n  let errorTimeStr = errorTime(arrayOfTimestamps);\n  let acp = arrayOfTimestamps.filter(d => d.type === \"Progress\");\n  let acp_transformed = acp.map(action => {\n    let message = action.message.split(' ');\n    let localTime = toLocal(action.time);\n    return {\n      Time: localTime,\n      Step: message[0],\n      Stage: message[1].split(':')[1],\n      Index: Number(message[2].split(':')[1])\n    };\n  });\n  let acp_started = acp_transformed.filter(action => action.Step === \"Starting\").map(action => {\n    return {\n      Stage: action.Stage,\n      Index: action.Index,\n      StartTime: action.Time\n    };\n  });\n  let acp_completed = acp_transformed.filter(action => action.Step === \"Completed\").map(action => {\n    return {\n      Stage: action.Stage,\n      Index: action.Index,\n      CompleteTime: action.Time\n    };\n  });\n  let acp_timestamp = acp_started.map(action => {\n    let completeTimeMessage = acp_completed.find(c => c.Stage === action.Stage && c.Index === action.Index);\n    return {\n      Stage: action.Stage,\n      Index: action.Index,\n      StartTime: action.StartTime,\n      CompleteTime: completeTimeMessage ? completeTimeMessage.CompleteTime : errorTimeStr,\n      Succeed: !!completeTimeMessage\n    };\n  });\n  return acp_timestamp;\n}\n\nfunction errorTime(arrayOfTimestamps) {\n  let errorMessage = arrayOfTimestamps.find(d => d.object === \"WebClient\" && d.type === \"ERROR\");\n  let errorTime = errorMessage ? errorMessage.time : null;\n  return errorTime;\n}\n\nfunction timestamps(row_lines) {\n  let arrayOfLines = row_lines.filter(line => line.match(\"time\"));\n  let tmpArrayOfLines = [...arrayOfLines];\n  tmpArrayOfLines.splice(0, 1);\n  return tmpArrayOfLines.map(line => JSON.parse(line));\n}\n\nfunction time_diff(start_time, complete_time) {\n  let start = start_time.split(':').map(t => Number(t));\n  let start_sec = start[0] * 3600 + start[1] * 60 + start[2];\n  let complete = complete_time.split(':').map(t => Number(t));\n  let complete_sec = complete[0] * 3600 + complete[1] * 60 + complete[2];\n  let diff_sec = complete_sec - start_sec;\n  return diff_sec;\n}\n\nfunction secToHHMMSS(time) {\n  return new Date(time * 1000).toISOString().substr(11, 8);\n}\n\nfunction toLocal(hhmmss) {\n  if (!hhmmss) return null;\n  let [HH, MM, SS] = hhmmss.split(':');\n  let local = [Number(HH) + 3, MM, SS].join(':');\n  return local;\n}","map":null,"metadata":{},"sourceType":"module"}